[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STA 2300 Intro to Data Science",
    "section": "",
    "text": "Introduction\nThese are the lecture notes for STA 2300 - Intro to Data Science\nPrerequisites: None\n\nCourse Description:\nPrinciples of data science, including problem workflow, variable types, visualization, modeling, programming, data management and cleaning, reproducibility, and big data."
  },
  {
    "objectID": "01.html#objectives",
    "href": "01.html#objectives",
    "title": "\n1  Session 1 – R setup\n",
    "section": "Objectives",
    "text": "Objectives\n\n\nExplore the data‑science lifecycle. The R for Data Science introduction models data science as a cycle: you begin by importing and tidying raw data; then understand it through an iterative loop of transforming, visualising and modelling; and finally communicate your results. Programming surrounds all of these steps and supports them. Today you will learn why each component is important and how they connect.\n\nRecognise the tools you need. To run the code in R for Data Science you need R, RStudio, the tidyverse package collection and a handful of other packages. We will install R (from the Comprehensive R Archive Network), download RStudio (an integrated development environment), and install the tidyverse.\n\nPrepare your computing environment. By the end of class you should have R and RStudio installed, know how to install and load packages, and be able to run simple R commands (arithmetic, vector creation, summary statistics). We will also introduce a dataset that you will revisit throughout the semester."
  },
  {
    "objectID": "01.html#notes",
    "href": "01.html#notes",
    "title": "\n1  Session 1 – R setup\n",
    "section": "Notes",
    "text": "Notes\nThe data‑science workflow\nData science is not a linear process. You first import data from files, databases or the web; tidy it so that each variable is a column and each observation a row; transform, visualise and model your data in an iterative loop to understand patterns and relationships; and then communicate your findings to others. Programming is a cross‑cutting skill that supports each of these phases. Throughout this course, you will move back and forth between these steps rather than following them in a strict order.\nTools and setup\nYou need four things to run the book’s code: R, RStudio, the tidyverse and some additional packages.\n\n\nR is the programming language you will use. Download the latest version from CRAN at https://cloud.r-project.org. A new major version of R is released once a year, with minor versions in between; updating regularly ensures compatibility.\n\n\nRStudio is an integrated development environment (IDE) for R. Download it from https://posit.co/download/rstudio-desktop/. RStudio is updated a couple of times a year. When you start RStudio, you will see a console pane for typing R code and an output pane for plots.\n\nThe tidyverse is a collection of packages for data manipulation, visualization and programming. To install all core tidyverse packages at once, run install.packages(\"tidyverse\") in the R console. After installation, load the tidyverse with library(tidyverse); this attaches packages such as dplyr, ggplot2, tidyr, readr, stringr, forcats, lubridate, purrr and tibble. You only need to install a package once, but you must load it in each new R session.\n\nOther packages. We will occasionally use packages outside the tidyverse (e.g., palmerpenguins, nycflights13, arrow, rvest, duckdb). When you encounter an error that a package is not installed, run install.packages(\"package_name\") to install the package.\nInstalling and testing your environment\n\n\nInstall R and RStudio as described above. Accept the default installation options.\n\n\nInstall the tidyverse. Open RStudio and run the following in the console:\n\n\ninstall.packages(\"tidyverse\")   # installs core tidyverse packages\nlibrary(tidyverse)               \n\n\n\nTry basic R commands. Use R as a calculator and practise creating vectors and computing summaries:\n\n\n2 + 2                  # arithmetic\n\n[1] 4\n\nx &lt;- c(1, 2, 3, 5, 7)  # create a numeric vector\nx * 2                  # vectorised multiplication\n\n[1]  2  4  6 10 14\n\nmean(x)                # compute the average\n\n[1] 3.6\n\nsum(x &gt; 4)             # count values greater than 4 (logical vector)\n\n[1] 2\n\n\nNotice that R performs operations element‑wise on vectors, and the assignment operator &lt;- stores values. Use descriptive variable names and indent your code neatly; we will discuss code style in a later class.\nTake‑aways\n\nThe data‑science process is iterative, looping through import, tidy, transform, visualize, model and communicate. Understanding develops as you cycle through these steps.\nTo do data science in R you need the R language, the RStudio IDE, the tidyverse package collection and other supporting packages. Installing and loading packages early will save time later.\nR is vectorized: arithmetic operations and functions operate on entire vectors. Use the assignment operator &lt;- to store results and choose descriptive variable names to write readable code."
  },
  {
    "objectID": "02.html#objectives",
    "href": "02.html#objectives",
    "title": "\n2  Session 2 – Data visualization basics\n",
    "section": "Objectives",
    "text": "Objectives\n\n\nAppreciate the importance of visualization. A simple graph can convey more information than any other device. You will learn how the grammar of graphics underlies ggplot2.\n\nCreate basic plots. Use ggplot2 to draw scatterplots, bar charts and histograms.\n\nUnderstand variable types. Recognize when to use different plot types based on whether variables are categorical or numeric.\n\nPrepare for layering. Today’s material sets the stage for Session 3 on layering, where you’ll add geoms, adjust positions and facet plots.\n\nNotes\nWhy use ggplot2? R has several systems for making graphs, but ggplot2 is one of the most elegant and versatile. It implements the grammar of graphics—a coherent system for describing and building graphs. Learning this grammar enables you to create a wide range of plots with consistent syntax.\nBuilding your first plots The data-visualization chapter starts with a simple scatterplot to illustrate aesthetic mappings and geometric objects. Aesthetic mappings tie variables to graphical properties (x and y positions, colour, shape), while geoms specify the type of plot.\n\n\nScatterplots show the relationship between two numeric variables. For example, plotting penguin flipper length vs. body mass can reveal whether larger penguins tend to have longer flippers. Map species or island to colour or shape to uncover additional structure.\n\nBar charts display the distribution of a categorical variable—for example, counting penguins by species.\n\nHistograms reveal the distribution of a numeric variable. Choose a bin width that balances detail with clarity.\n\nTo illustrate these concepts, load the tidyverse and palmerpenguins packages, then experiment with commands like:\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point()\n\n\n\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n\n\n\n\nBe sure to label axes and titles with labs(), choose appropriate scales, and consider transparency (alpha) to reduce overplotting.\nKey take‑awayss\n\n\nggplot2 implements a coherent grammar of graphics.\nScatterplots reveal relationships between numeric variables; bar charts and histograms show distributions.\nUnderstanding your variables (categorical vs. numeric) guides your choice of plot type."
  },
  {
    "objectID": "03.html#objectives",
    "href": "03.html#objectives",
    "title": "\n3  Session 3 – The layered grammar of graphics\n",
    "section": "Objectives",
    "text": "Objectives\n\n\nDeepen your understanding of ggplot2. Explore the layered grammar of graphics—how aesthetic mappings, geometric objects and facets combine to build complex plots.\n\nMaster aesthetic mappings. Map variables to color, shape, size and alpha correctly. Avoid mapping categorical variables to size or alpha (it implies a false ordering) and note that mapping a categorical variable to shape uses only six shapes, so additional groups are dropped.\n\nLayer multiple geoms. Add multiple geoms to a plot (e.g., points and smooth lines) and distinguish between global and local aesthetic mappings. Use the group aesthetic to draw separate curves for each category.\n\nUse faceting and coordinate systems. Split data into panels using facet_wrap() or facet_grid() and adjust scales. Experiment with coordinate transforms such as coord_flip() and coord_polar()."
  },
  {
    "objectID": "03.html#notes",
    "href": "03.html#notes",
    "title": "\n3  Session 3 – The layered grammar of graphics\n",
    "section": "Notes",
    "text": "Notes\nLayered grammar of graphics – Every plot can be built from layers consisting of data, aesthetic mappings, geoms, optional statistical transformations, position adjustments and a coordinate system. Building plots layer by layer allows incremental refinement.\nAesthetic mappings – The aes() function connects variables to graphical attributes. Mapping a categorical variable to color is generally safe; mapping it to shape works but only six shapes are available; mapping to size or alpha is discouraged and yields warnings.\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# Mapping species to color and shape (safe if ≤ 6 categories)\nggplot(penguins, aes(x = flipper_length_mm,\n                     y = body_mass_g,\n                     color = species,\n                     shape = species)) +\n  geom_point()\n\n\n\n# Mapping a categorical variable to size or alpha generates warnings\nggplot(penguins, aes(x = flipper_length_mm,\n                     y = body_mass_g,\n                     size = species)) +\n  geom_point()  # Warning: Using size for a discrete variable is not advised\n\n\n\n\nMappings defined in ggplot() apply globally, while mappings inside a geom override them for that layer.\n\n# Global mapping applies color to both geoms\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", se = FALSE)\n\n\n\n# Local mapping overrides global color for the point layer only\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species)) +\n  geom_smooth(method = \"loess\", se = FALSE)\n\n\n\n\nLayering geoms – Different geoms (e.g., geom_point, geom_smooth, geom_bar) draw different types of objects. Overlaying geoms reveals multiple aspects of the data. When using geoms like geom_smooth(), ggplot2 automatically groups data by discrete variables; you can explicitly set group to control grouping.\n\n# Overlay scatterplot with separate curves per species\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species)) +\n  geom_smooth(aes(group = species), method = \"loess\", se = FALSE)\n\n\n\n\nFacets – Use facet_wrap() to create a grid of subplots for one categorical variable, and facet_grid() for two variables. You can allow axes to vary across facets with the scales argument.\n\n# Facet by island\nggplot(penguins, aes(x = body_mass_g, y = flipper_length_mm)) +\n  geom_point() +\n  facet_wrap(~ island)\n\n\n\n# Facet by species and sex with free y‑axis\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point() +\n  facet_grid(species ~ sex, scales = \"free_y\")\n\n\n\n\nCoordinate systems – Transform plots using different coordinate systems to improve interpretability. For example, swap axes using coord_flip() or create a polar bar chart with coord_polar().\n\n# Flip axes in a boxplot\nggplot(penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n# Polar coordinates for a bar chart\nggplot(penguins, aes(x = species, fill = species)) +\n  geom_bar() +\n  coord_polar()"
  },
  {
    "objectID": "04.html#objectives",
    "href": "04.html#objectives",
    "title": "\n4  Session 4 – Data transformation (I): filtering, arranging, selecting and mutating\n",
    "section": "Objectives",
    "text": "Objectives\n\n\nUnderstand the purpose of data transformation. You rarely get data in exactly the form needed for analysis. Transformation involves creating new variables, reordering or selecting observations, and renaming columns.\n\nUse dplyr verbs to manipulate rows and columns. Learn filter() to subset rows, arrange() to reorder rows, select() and rename() to choose or rename variables, and mutate() to create new columns.\n\nChain operations with the pipe. Use the pipe (|&gt; in base R or %&gt;% from magrittr) to express sequences of transformations in a readable way.\n\nNotes\nKey dplyr verbs – This session covers four of the five core verbs of dplyr:\n\n\nPick observations by their values: filter() subsets rows based on logical conditions.\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n# Filter penguins to only Adelie species on Dream island\nadelie_dream = penguins |&gt; \n  filter(species == \"Adelie\", island == \"Dream\")\n\nadelie_dream |&gt; head()\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Dream            39.5          16.7               178        3250\n2 Adelie  Dream            37.2          18.1               178        3900\n3 Adelie  Dream            39.5          17.8               188        3300\n4 Adelie  Dream            40.9          18.9               184        3900\n5 Adelie  Dream            36.4          17                 195        3325\n6 Adelie  Dream            39.2          21.1               196        4150\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nfilter() takes the data frame as its first argument and any number of logical expressions as additional arguments. It returns a new data frame and does not modify the original.\n\n\nReorder the rows: arrange() sorts rows by one or more variables. Use desc() for descending order and remember that missing values are sorted to the end.\n\n# Arrange penguins by body mass (descending) and flipper length (ascending)\npenguins_sorted = penguins |&gt; \n  arrange(desc(body_mass_g), flipper_length_mm)\n\npenguins_sorted |&gt; head()\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Gentoo  Biscoe           49.2          15.2               221        6300\n2 Gentoo  Biscoe           59.6          17                 230        6050\n3 Gentoo  Biscoe           51.1          16.3               220        6000\n4 Gentoo  Biscoe           48.8          16.2               222        6000\n5 Gentoo  Biscoe           45.2          16.4               223        5950\n6 Gentoo  Biscoe           49.8          15.9               229        5950\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\nPick variables by their names: select() quickly narrows a data frame to relevant columns. It supports helper functions like starts_with(), ends_with(), and contains().\n\n# Select species, island and body_mass_g columns\npenguins_subset = penguins |&gt; \n  select(species, island, body_mass_g)\n\npenguins_subset |&gt; head()\n\n# A tibble: 6 × 3\n  species island    body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;           &lt;int&gt;\n1 Adelie  Torgersen        3750\n2 Adelie  Torgersen        3800\n3 Adelie  Torgersen        3250\n4 Adelie  Torgersen          NA\n5 Adelie  Torgersen        3450\n6 Adelie  Torgersen        3650\n\n# Select all columns except those from bill_length to bill_depth\npenguins_except = penguins |&gt; \n  select(-(bill_length_mm:bill_depth_mm))\n\npenguins_except |&gt; head()\n\n# A tibble: 6 × 6\n  species island    flipper_length_mm body_mass_g sex     year\n  &lt;fct&gt;   &lt;fct&gt;                 &lt;int&gt;       &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n1 Adelie  Torgersen               181        3750 male    2007\n2 Adelie  Torgersen               186        3800 female  2007\n3 Adelie  Torgersen               195        3250 female  2007\n4 Adelie  Torgersen                NA          NA &lt;NA&gt;    2007\n5 Adelie  Torgersen               193        3450 female  2007\n6 Adelie  Torgersen               190        3650 male    2007\n\n\nTo rename a column without dropping others, use rename().\n\n# Rename flipper_length_mm to flipper_mm\npenguins = penguins |&gt; \n  rename(flipper_mm = flipper_length_mm)\n\npenguins |&gt; head()\n\n# A tibble: 6 × 8\n  species island bill_length_mm bill_depth_mm flipper_mm body_mass_g sex    year\n  &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;      &lt;int&gt;       &lt;int&gt; &lt;fct&gt; &lt;int&gt;\n1 Adelie  Torge…           39.1          18.7        181        3750 male   2007\n2 Adelie  Torge…           39.5          17.4        186        3800 fema…  2007\n3 Adelie  Torge…           40.3          18          195        3250 fema…  2007\n4 Adelie  Torge…           NA            NA           NA          NA &lt;NA&gt;   2007\n5 Adelie  Torge…           36.7          19.3        193        3450 fema…  2007\n6 Adelie  Torge…           39.3          20.6        190        3650 male   2007\n\n\n\n\nCreate new variables: mutate() adds new columns that are functions of existing columns. You can refer to variables created earlier in the same call.\n\n# Compute ratio of body mass to flipper length and total bill size\npenguins = penguins |&gt; \n  mutate(\n    mass_per_flipper = body_mass_g / flipper_mm,\n    bill_size = bill_length_mm + bill_depth_mm\n  )\n\npenguins |&gt; head()\n\n# A tibble: 6 × 10\n  species island bill_length_mm bill_depth_mm flipper_mm body_mass_g sex    year\n  &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;      &lt;int&gt;       &lt;int&gt; &lt;fct&gt; &lt;int&gt;\n1 Adelie  Torge…           39.1          18.7        181        3750 male   2007\n2 Adelie  Torge…           39.5          17.4        186        3800 fema…  2007\n3 Adelie  Torge…           40.3          18          195        3250 fema…  2007\n4 Adelie  Torge…           NA            NA           NA          NA &lt;NA&gt;   2007\n5 Adelie  Torge…           36.7          19.3        193        3450 fema…  2007\n6 Adelie  Torge…           39.3          20.6        190        3650 male   2007\n# ℹ 2 more variables: mass_per_flipper &lt;dbl&gt;, bill_size &lt;dbl&gt;\n\n\nIf you only want to keep the new variables, use transmute().\n\n\nCombining operations with the pipe – Stringing multiple operations together can be awkward when saving intermediate objects. The pipe (|&gt; or %&gt;%) passes the result of one call to the next, making code easier to read.\n\n# Calculate average body mass by species in a single pipeline\nspecies_summary = penguins |&gt;\n  group_by(species) |&gt;\n  summarise(\n    count = n(),\n    mean_mass = mean(body_mass_g, na.rm = TRUE)\n  ) |&gt;\n  arrange(desc(mean_mass))\n\nspecies_summary |&gt; head()\n\n# A tibble: 3 × 3\n  species   count mean_mass\n  &lt;fct&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Gentoo      124     5076.\n2 Chinstrap    68     3733.\n3 Adelie      152     3701.\n\n\nThe pipe should be read as “then”: group by species then summarise then arrange the result."
  }
]